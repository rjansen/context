NAME 		:= dispatcher_tools
FUNCTION    ?= smsserver
REPO       	:= $(NAME)/functions/$(FUNCTION)
BUILD       := $(shell git rev-parse --short HEAD)
VERSION     := $(shell git describe --tags $(shell git rev-list --tags --max-count=1))
MAKEFILE    := $(word $(words $(MAKEFILE_LIST)), $(MAKEFILE_LIST))
BASE_DIR    := $(shell cd $(dir $(MAKEFILE)); pwd)
ALLPKGS    	:= $(shell go list ./... | grep -v /vendor/)
PKGS       	:= $(shell go list ./... | grep -v /vendor/ | grep -v /itest)
IPKGS      	:= $(shell go list ./... | grep -v /vendor/ | grep /itest)

# Test and Benchmark Parameters
TEST_PKGS ?=
TESTS ?= .
COVERAGE_FILE := $(NAME).coverage
COVERAGE_HTML := $(NAME).coverage.html
PKG_COVERAGE := $(NAME).pkg.coverage

ENV ?= local

.PHONY: default
default: build

.PHONY: install
install: install.tools install.deps
	@echo "$(REPO) installed successfully"

.PHONY: install.deps
install.deps: workspace
	go get -u github.com/Masterminds/glide

.PHONY: workspace
workspace: install.tools
	gvm use go1.10.1

.PHONY: install.tools
install.tools:
	#if [[ ! which gvm ]]; then \
	   # bash < <(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)
	   # gmv install go1.10.1; \
	#fi
	#Create abstraction to install into linux distro too
	#if [[ ! $$(which direnv) ]]; then \
	#	brew install direnv; \
	#fi
	#Create abstraction to install into linux distro too
	#if [[ ! $$(which direnv) ]]; then \
	#	curl https://raw.githubusercontent.com/apex/apex/master/install.sh | sudo sh; \
	#fi

.PHONY: setup
setup: workspace
	@echo "$(REPO) setup successfully"
	glide sync

.PHONY: all
all: build test bench coverage

.PHONY: build
build:
	@echo "Building: $(REPO)@$(VERSION)-$(BUILD)"
	go build -o $(FUNCTION) $(REPO)

.PHONY: deploy
deploy:
	@echo "Deploying: $(REPO)@$(VERSION)-$(BUILD)"
	apex deploy --profile $(AWS_PROFILE) $(FUNCTION)

.PHONY: default
default: build

local:
	@echo "Set enviroment to local"
	$(eval ENV = local)

.PHONY: dev
dev:
	@echo "Set enviroment to dev"
	$(eval ENV = dev)

.PHONY: prod
prod:
	@echo "Set enviroment to prod"
	$(eval ENV = prod)

.PHONY: check_env
check_env:
	@if [ "$(ENV)" == "" ]; then \
	    echo "Env is blank: $(ENV)"; \
	    exit 540; \
	fi

.PHONY: run
run: build
	./$(NAME)

.PHONY: debug
debug: build
	gdb ./$(NAME)

.PHONY: clean
clean:
	-rm $(NAME)*coverage*
	-rm *.test
	-rm *.pprof

.PHONY: reset
reset: clean
	-cd vendor; rm -r */

.PHONY: test
test:
	#go test -v -race $(ALLPKGS)
	@if [ "$(TEST_PKGS)" == "" ]; then \
	    echo "Unit Test All Pkgs with Selected Tests=$(TESTS)";\
		go test -v -race -run $(TESTS) $(PKGS) || exit 501;\
	else \
	    echo "Unit Test Selected Pkgs=$(TEST_PKGS) with Selected Tests=$(TESTS)";\
	    for tstpkg in $(TEST_PKGS); do \
			go test -v -race -run $(TESTS) $(REPO)/$$tstpkg || exit 501;\
		done; \
	fi

.PHONY: itest
itest:
	@if [ "$(TEST_PKGS)" == "" ]; then \
	    echo "Integration Test All Pkgs";\
		go test -v -race $(IPKGS) || exit 501;\
	else \
	    echo "Integration Unit Test Selected Pkgs=$(TEST_PKGS)";\
	    for tstpkg in $(TEST_PKGS); do \
			go test -v -race $(REPO)/$$tstpkg/itest || exit 501;\
		done; \
	fi

.PHONY: bench
bench:
	#go test -bench=. -run="^$$" -cpuprofile=cpu.pprof -memprofile=mem.pprof -benchmem $(IPKGS)
	#go test -bench=. -run="^$$" -benchmem $(PKGS)
	@if [ "$(TEST_PKGS)" == "" ]; then \
	    echo "Benchmark all Pkgs" ;\
	    for tstpkg in $(IPKGS); do \
		    go test -bench=. -run="^$$" -cpuprofile=cpu.pprof -memprofile=mem.pprof -benchmem $$tstpkg || exit 501;\
		done; \
	else \
	    echo "Benchmark Selected Pkgs=$(TEST_PKGS)" ;\
	    for tstpkg in $(TEST_PKGS); do \
		    go test -bench=. -run="^$$" -cpuprofile=cpu.pprof -memprofile=mem.pprof -benchmem $(REPO)/$$tstpkg/itest || exit 501;\
		done; \
	fi

.PHONY: coverage
coverage:
	@echo "Testing with coverage"
	@echo 'mode: set' > $(COVERAGE_FILE)
	@touch $(PKG_COVERAGE)
	@touch $(COVERAGE_FILE)
	@if [ "$(TEST_PKGS)" == "" ]; then \
		for pkg in $(ALLPKGS); do \
			go test -v -coverprofile=$(PKG_COVERAGE) $$pkg || exit 501; \
			if (( `grep -c -v 'mode: set' $(PKG_COVERAGE)` > 0 )); then \
				grep -v 'mode: set' $(PKG_COVERAGE) >> $(COVERAGE_FILE); \
			fi; \
		done; \
	else \
	    echo "Testing with covegare the Pkgs=$(TEST_PKGS)" ;\
	    for tstpkg in $(TEST_PKGS); do \
			go test -v -coverprofile=$(PKG_COVERAGE) $(REPO)/$$tstpkg || exit 501; \
			if (( `grep -c -v 'mode: set' $(PKG_COVERAGE)` > 0 )); then \
				grep -v 'mode: set' $(PKG_COVERAGE) >> $(COVERAGE_FILE); \
			fi; \
		done; \
	fi
	@echo "Generating report"
	@go tool cover -html=$(COVERAGE_FILE) -o $(COVERAGE_HTML)
	open $(COVERAGE_HTML) || google-chrome $(COVERAGE_HTML)

.PHONY: coverage
docker_build_run: docker_build docker_run

.PHONY: docker_build
docker_build:
	@echo "---- Create image to build ----"
	@docker build -t golangbuild .
	@echo "---- Create function bin: $(FUNCTION) ----"
	@docker run --rm -u 1000 -e GLIDE_HOME="/tmp" -w="/go/src/$(REPO)" -v `pwd`:/go/src/$(REPO) golangbuild

.PHONY: docker_run
docker_run:
	@echo "---- Run builded image ----"

